// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: token_queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const cleanupRefreshTokensExpiredBefore = `-- name: CleanupRefreshTokensExpiredBefore :exec
DELETE FROM auth.user_refresh_tokens 
WHERE expires_at < COALESCE($1, NOW())
`

func (q *Queries) CleanupRefreshTokensExpiredBefore(ctx context.Context, expiresAt time.Time) error {
	_, err := q.db.ExecContext(ctx, cleanupRefreshTokensExpiredBefore, expiresAt)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO auth.user_refresh_tokens (
    user_id,
    token_hash,
    created_at,
    expires_at
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, token_hash, created_at, expires_at, revoked_at
`

type CreateRefreshTokenParams struct {
	UserID    int64
	TokenHash string
	CreatedAt time.Time
	ExpiresAt time.Time
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (AuthUserRefreshToken, error) {
	row := q.db.QueryRowContext(ctx, createRefreshToken,
		arg.UserID,
		arg.TokenHash,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	var i AuthUserRefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const getUserRefreshTokenByTokenHash = `-- name: GetUserRefreshTokenByTokenHash :one
SELECT id, user_id, token_hash, created_at, expires_at, revoked_at FROM auth.user_refresh_tokens 
WHERE user_id = $1
    AND token_hash = $2
`

type GetUserRefreshTokenByTokenHashParams struct {
	UserID    int64
	TokenHash string
}

func (q *Queries) GetUserRefreshTokenByTokenHash(ctx context.Context, arg GetUserRefreshTokenByTokenHashParams) (AuthUserRefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getUserRefreshTokenByTokenHash, arg.UserID, arg.TokenHash)
	var i AuthUserRefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const getUserRefreshTokensExpiresAfter = `-- name: GetUserRefreshTokensExpiresAfter :many
SELECT id, user_id, token_hash, created_at, expires_at, revoked_at FROM auth.user_refresh_tokens 
WHERE user_id = $1 
    AND expires_at > $2
ORDER BY expires_at DESC
`

type GetUserRefreshTokensExpiresAfterParams struct {
	UserID    int64
	ExpiresAt time.Time
}

func (q *Queries) GetUserRefreshTokensExpiresAfter(ctx context.Context, arg GetUserRefreshTokensExpiresAfterParams) ([]AuthUserRefreshToken, error) {
	rows, err := q.db.QueryContext(ctx, getUserRefreshTokensExpiresAfter, arg.UserID, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthUserRefreshToken
	for rows.Next() {
		var i AuthUserRefreshToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeUserAllRefreshTokensAfter = `-- name: RevokeUserAllRefreshTokensAfter :exec
UPDATE auth.user_refresh_tokens 
SET revoked_at = COALESCE($2, NOW())
WHERE user_id = $1 AND expires_at > COALESCE($2, NOW())
`

type RevokeUserAllRefreshTokensAfterParams struct {
	UserID    int64
	RevokedAt sql.NullTime
}

func (q *Queries) RevokeUserAllRefreshTokensAfter(ctx context.Context, arg RevokeUserAllRefreshTokensAfterParams) error {
	_, err := q.db.ExecContext(ctx, revokeUserAllRefreshTokensAfter, arg.UserID, arg.RevokedAt)
	return err
}

const revokeUserRefreshToken = `-- name: RevokeUserRefreshToken :exec
UPDATE auth.user_refresh_tokens 
SET revoked_at = COALESCE($2, NOW())
WHERE token_hash = $1 AND revoked_at IS NULL
`

type RevokeUserRefreshTokenParams struct {
	TokenHash string
	RevokedAt sql.NullTime
}

func (q *Queries) RevokeUserRefreshToken(ctx context.Context, arg RevokeUserRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, revokeUserRefreshToken, arg.TokenHash, arg.RevokedAt)
	return err
}
